                           Asteroids                         by Joaquin Gaviot   =================================================================================================    Design and Mechanics=================================================================================================	-------------------------------------------------------------------------------------------------Player controls:     W: forward.    S: backward.    A: rotate counter-clockwise.    D: rotate clockwise.    Space (can keep pressed): shoot projectile.     E (keep pressed): hyperspace travel. -------------------------------------------------------------------------------------------------Player stats: I decided to give health to the player cause the difficulty of the game could be too high for a single life.I replaced the temporary shield for a health based permanent shield.The health will be reduced in 1 foreach collision or shoot that the player receives, this includes the shield health too.The player can get different levels of shoot when it get the weapon power-up.* Health: 10 * Shield Health: 4* Weapons:    Level 1: one single shoot.    Level 2: 3 shots for the front.    Level 3: 6 shots, 3 for the front and 3 for backward.    Level 4: 10 shoots, 3 for the front, 3 for backward and 2 foreach side.* Invulnerability: when the player receives damage it activates an invulnerability timer.-------------------------------------------------------------------------------------------------Asteroids:There are 4 sizes of asteroids: * Bigger* Medium* Small * TinyEach size as his own attributes that are:+ max speed+ size (used for explosions) + different shapes+ mass+ healthWhen an asteroid is destroyed it will spawn 3 asteroids from the immediate next smaller level, except for the Tiny level that is the smallest. The asteroids can collide with each other and change their linear speed and angular speed depending on physics.The tiny asteroids will be destroyed if they collide with a bigger asteroid, this is to avoid the entropy caused by the collisions. When a player or another ship collides with an asteroid, the ship will be stunned for a short amount of time and it will be pushed away. In the case of the player it will receive 1 point of damage. Enemies will not receive damage from asteroid collisions.-------------------------------------------------------------------------------------------------Enemies:The enemies' controls are very similar to player controls, most of the systems are shared between them. The main difference is on the system that controls the input. The enemies have an AI system based on a state machine with 4 states:* Idle: The enemy will moves forward and check every frame:obstacles in the front: in this case the state changes to Avoiding.distance to player: in this case the state changes to Aggro.* Avoiding:The enemy checks the obstacle velocity and makes the decision to rotate 90 degrees in order to avoid the obstacle. This state is executed during a time calculated according to the enemy angular speed. After finishing the timer it will return to Idle state.* Aggro:The enemy puts the ship in a position perpendicular to the player direction and changes the state to Attacking.The shoot has a cooldown and this state checks and reduces that cooldown before changing to Attacking.If the enemy detects an obstacle in the front before reaching the position to attack the state will be changed to Avoiding.If the distance to player is bigger than a value the state will be changed to Idle * Attacking:The enemy aims the player and shoot a bullet to the player direction, after that the state is changed to Aggro The enemy bullets can collide with other enemies and asteroids that make the game funniest. Enemy AI States Diagram:                               ┌───────────────┐                              │detect obstacle│          ╔══════════╗        └──────┬────────┘           ╔══════════╗          ║          ║═══════════════╧═══════════════════►║          ║       ╔══║   Idle   ║◄════════════════╤══════════════════║ Avoiding ║       ║  ║          ║◄═════╗    ┌─────┴──────┐     ╔════►║          ║       ║  ╚══════════╝      ║    │end avoiding│     ║     ╚══════════╝       ║                    ║    └────────────┘     ║        ║ ┌───────────┐      ║ ┌───────────────┐     ║        ║ │player dist│      ║ │  player dist  │     ║        ╟─┤    <      │      ╟─┤      >        │     ║        ║ │ view dist │      ║ │view dist * 1.5│     ║        ║ └───────────┘      ║ └───────────────┘     ║        ║                    ║   ┌───────────────┐   ║        ║       ╔═════════╗  ║   │detect obstacle│   ║        ╚══════►║         ║══╝   └──────┬────────┘   ║    ╔═══════════╗               ║  Aggro  ║═════════════╧════════════╝    ║           ║           ╔══►║         ║════════════╤═════════════════►║ Attacking ║           ║   ╚═════════╝       ┌────┴────┐             ║           ║═══╗            ║                     │can shoot│             ╚═══════════╝   ║            ║                     └─────────┘                             ║            ╚══════════════════════════╤══════════════════════════════════╝                                  ┌────┴──────┐                                  │after shoot│                                  └───────────┘ Enemy Aim:The enemies will spawn an aim from his position to the player position when the AIState changes to Attacking and before shooting the missile.The aim is represented by a quad and is positioned using an Non Uniform Scale, the Rotation and Translation in the next way.When the aim is disabled the system assigns to the Non Uniform Scale the value (0,0,1).If the aim is enabled it needs to use the player position to calculate the direction and the distance. Then, using these values, calculate the rotation angle and position the aim in the right place. The translation is calculated using a down vector rotated over the rotation angle and multiplied by the distance divided by 2. The down vector is because the ship model forward is looking down.    rotation = rotation angle    scale = (x = aimWidth, y = distance to player, z = 1)    translation = rotated vector * distance * 0.5 -------------------------------------------------------------------------------------------------Powers: The powers are spawned in the same position where an asteroid or enemy were destroyed. The asteroids that can spawn powers are Bigger and Medium only.Powers disappear when the player collides with them and give to the player something.The powers the player can get are 4:Weapon:Increase the current weapon level, the max level is 4.Health:Increase the current health in 2, the max health is 10. Shield:Create a shield with 4 points of health, if it exists just restore the shield health.Bomb:Explodes at the same time the player gets this power.The radius increases during a few secondsIt will destroy every asteroid and enemy that collides with the bomb circle        		The spawned asteroids after the destruction of their parent will not receive damage from the bomb cause saves an unique bomb id.This can cause inconsistency when 2 or more bombs explode simultaneously but this case is not so frequent.Hyperspace Travel Ability: This ability teleports the player ship to a random position inside the screen. It needs to be charged by keep pressing the ability button.After charge it will activate the travel and enter in a cooldown state. The states of this mechanics are: Enabled: the travel is ready to use. Charging: the button is pressed and the travel is charging.Traveling: after traveling it should send an event to stop travel sound.Reloading: travel ability cooldown.Hyperspace Travel States Diagram:                              ┌─────────────────┐                              │ button released │          ╔═══════════╗       └─────────┬───────┘          ╔════════════╗          ║           ║◄════════════════╧══════════════════║            ║       ╔═►║  Enabled  ║═══════════════╤═══════════════════►║  Charging  ║════╗       ║  ║           ║         ┌─────┴────────┐           ║            ║    ║       ║  ╚═══════════╝         │button pressed│           ╚════════════╝    ║       ║                        └──────────────┘                             ║       ║ ┌───────────────┐                             ┌──────────────────┐  ║       ║ │ chargeTimer   │                             │   chargeTimer    │  ║       ╟─┤     >=        │                             │       >=         ├──╢       ║ │ timeReloading │                             │ timeBeforeTravel │  ║       ║ └───────────────┘                             └──────────────────┘  ║       ║                                                                     ║       ║                                                                     ║       ║       ╔═════════════╗                           ╔═════════════╗     ║       ║       ║             ║                           ║             ║     ║       ╚═══════║  Reloading  ║◄═══════════╤══════════════║  Traveling  ║◄════╝               ║             ║    ┌───────┴─────────┐    ║             ║                ╚═════════════╝    │  chargeTimer    │    ╚═════════════╝                                   │      >=         │                                   │ timeAfterTravel │                                   └─────────────────┘ ======================================================================    Graphics =====================================================================The graphics are line shapes with a single color.I created a shader that computes the alpha channel value depending on the uv coordinates in the next way.alpha = 1 if uv.y < threshold.alpha = 0 if uv.y >= threshold.I called it a line shader.I used the Unity PolygonCollider2D component to draw the vertices of the shapes according to the sprite models shape, this taking into account that the ECS physics support a maximum of 16 points per collider, then I used it to create a plane mesh with the idea of draw only the shape borders.The idea is to create a mesh with uv.y = 0 on the vertices that should be drawn and uv.y = 1 on a center point common to all triangles, this causes the result of drawing only a portion from the base of the triangle. First of all I should compute the center point, I called it center of mass. This is the sum of all vertices of the shape divided by the vertices count. Using this center of mass I can start to create the vertices and uvs array. The vertices are the same vertices as the shape but adding the center of mass on the end. The uvs are all (0,0) except by the uv corresponding to the center of mass vertex that is (1,1)Then, I start to create the indices array, suppose I have an N vertices shape and I created a N+1 vertices array that contains the vertices of the shape and the center of mass.I get 2 consecutive indices, for example 0 and 1 and put it on the indices then put the N index that corresponds to the center of mass to create a triangle between 2 shape points and the center of mass. In the case the first point is the last shape point (N), the next point index will be 0.	We need to have careful with the draw triangles direction here, taking into account that the shape vertices order should follow a right hand rule and the Unity face culling winding order is clockwise then the triangle indice should be posted like (0,N,1),(1,N,2),...(N-1,N,0).Another point to take into account is that the shape should be a little bit regular to automate this idea into a simple algorithm that creates the meshes using only the shape points. When the line shader draws the mesh and the uvs are computed, there is an interpolation between the uv values of each triangle resulting that the fragments now contains a 0 to 1 number according to the distance from the triangle's base (shape points) to the triangle's top (center of mass), if I set a value to the alpha channel according to this uv value, then it will draw a line in the base of the triangle. Uvs example: Suppose this shape and the X is the center of mass, here I have 4 triangles.(0,X,1) - (1,X,2) - (2,X,3) - (3,X,0) And suppose two points A and B if we interpolate the uvs between point 1 and 2 the result is always (0,0), then the uv of point B has a value close to 0.If we interpolate the uvs between the middle of segment 1,2 and the point X, the result indicates that the uvs of point A is close to 1. Now using a threshold to determine the alpha channel value we can see that the B point should be 1 and A point should be 0.			     (0,0)             (0,0)				3╔───────────────╗2				 │               │				 │               │				 │     (1,1)     │				 │       X *    *│				 │         A    B│				 │               │				 │               │				0╚───────────────╝1			     (0,0)             (0,0)The numbers between () are the uvs.======================================================================        Physics======================================================================To manage physics I used the 2D Entities Physics 0.2.0-preview.5 package.I implemented my own collision system and use the physics velocity and the physics mass components for calculations.The colliders are PolygonCollider2D, the same I used to create the line shapes and I had to take into account that ECS physics only can convert colliders with 16 or less points.The collision system was done using the concept of elastic collision and quantity of motion. The main idea of collision systems is to check the collision with other entities in the physics world and calculate, using the mass, linear velocity and angular velocity, the resulting linear velocity vector and angular velocity after collision.I added to the equation a little change to take into account the collision direction, the vector between the two colliders world position to compute the resulting angular velocity and add to the resulting linear velocity a little variation depending on an approximation of collision point.To avoid the double calculation of the collision, because if we have two colliders the first is colliding with the second and vice versa, I only calculate one collision taking into account the higher speed or, if the speeds are the same, the higher distance to world center.Suppose we have two colliders collider 1 and collider 2 with mass M1 and M2 and their initial velocities V1_0 and V2_0, collider 1 will be the main collider, that has the higher speed or the farthest position to the world center.The resulting velocities are:    V1 = 2 * M2 * (V2_0 - V1_0) / (M1 + M2) + V1_0    V2 = 2 * M1 * (V1_0 - V2_0) / (M1 + M2) + V2_0Now I add a component to simulates the moment caused by the collision point Suppose the collision direction is D, and we have the V1 length and the V2 length called S1 and S2, and finally S1_0 and S2_0 are the lengths of V1_0 and V2_0 respectively.V1_F and V2_F are the final velocities.    V1_F = normalize(V1 - D * S1_0 * 0.5f) * S1    V2_F = normalize(V2 + D * S2_0 * 0.5f) * S2Now to calculate the angular velocity, suppose we have the vector F that is the direction of the higher velocity, and let's call S to the length of the rest between V1_0 and V2_0, in other words, the relative initial speed.We can calculate, if the speed is bigger than 0, the cross product between F and D, lets call it C.    C = cross(F,D)Where C is a normalized vector.Then, the resulting angular velocities are:    W1 = 2 * M2 * arcsine(cross.z) * S / (M1 + M2)    W2 = 2 * M1 * arcsine(cross.z) * S / (M1 + M2)The last step is to calculate the next position and set it to the Translation component.    P1 = P1_0 + V1_F * dt    P2 = P2_0 + V2_F * dtWhere P1_0 and P2_0 are the initial positions and dt is the delta time.=====================================================================ECS Design====================================================================-------------------------------------------------------------------------------------------------Data Models    GeneralLimitCheckComponent: This component has the Camera limits in world coordinates, assuming the camera is on (0,0) coordinate.I only need to know the maximum x and y coordinates. This component designates the entities that need to be kept inside the screen.HealthComponent: Represents the health of an entity. When this health is 0 the entity should be destroyed.    AsteroidsAsteroidComponent: Represents the asteroid attributes.type: the asteroid size type (bigger, medium, small, tiny).size: this number represents a value used to determine explode radius, child spawn positions and determine the amount of asteroids on screen.maxSpeed: clamps the linear speed.explodeDirection: last bullet impact direction to calculate the child spawn positions.lastBombID: saves the last bomb id that destroys this asteroid to avoid childs destruction by the same bomb.    Ships* ShipDataComponent: Saves the ship setup data values and these values depend on the type of  ship.     This component is set up on the entity creation and is used as read only.     + maxHealth: the maximum and start health.    + shieldHealth: the shield maximum health.    + maxSpeed: value to clamp the linear velocity.    + acceleration: the ship's acceleration when it moves forward or backward.    + rotationSpeedDeg: the rotation speed in degrees.    + restitution: the elastic crash restitution coefficient.    + stunnedTime: time that the sheep keeps stunned.    + invTime: the time that the ship keeps invulnerable after receiving damage.    + shootCooldown: the weapon cooldown. * ShipStatsComponent: represent the current attributes of the ship entity.    + entityType: used to determine if the entity is a player or an enemy.    + shieldHealth: saves the current shield health.    + stunnedTimer: when this value is bigger than 0 the ship is stunned and cannot move.    + invTime: invulnerability time, if this value is bigger than 0 the ship cannot receive      damage.    + shootTimer: weapon cooldown: if this value is bigger than 0 the ship cannot shoot.* ShipInputComponent: represents the controller of a ship.    + direction: represents the stick, x coordinate for rotation and y coordinate for move      forward and backward.    + shoot: shoot input pressed. * ShipRendererComponent: saves the references to the ship mesh renderer and the shield mesh  renderer.   In the case of enemies the shield was replaced by the aim. * WeaponComponent: saves the values of the shoot assigned to the ship.    + level: the weapon level is used to set the other values.    + missileSpeed: saves the missile speed.    + missileLifeTime: saves the missile lifetime.    + range: saves the missile range value.    + missileAmount: saves the amount of missiles that the shoot will spawn.    Player* PlayerComponent: this component is added to the player to differentiate his entity to the rest  of the ships.* ShieldComponent: represent the shield and should be assigned to the shield visuals entity (mesh   renderer).    + enabled: true if the shield visuals are enabled, false when they are disabled.    + firstDisabled: to avoid the first disabled event.* HyperspaceTravelComponent: Used by the hyperspace travel mechanic.    + state: the current travel state.    + timeBeforeTravel: time used to charge the ability before casting it.    + timeAfterTravel: time used to trigger the travel stop event after casting the ability.    + timeReloading: saves the cooldown needed to use the ability after casting it.    + chargeTimer: saves the current timer value.    + chargingPressed: it's true when the input key is pressed, false otherwise.    Enemies* EnemyComponent: Contains Enemy attributes related to Enemy AI.    + AIState: current enemy AI state.    + stateTimer: timer used to change state when it's done.    + viewDistance: saves the enemy view distance used to avoid obstacles or check the player       distance to set aggro state.* AimComponent: represents the enemy aim and it's used before shooting the player.    + timeAming: the time the enemy would aim the player.    + aimTimer: timer.    + aimWidth: the visual width of the aim.    Missiles* MissileComponent: represents the missile for player and enemies.    + owner: contains the owner Entity, to avoid the possibility of receive self damage    + speed: the missile linear speed.    + range: the length of the raycast hit, calculated from the current missile position    + timer: the missile lifetime.    Others* PowerComponent: represents the pickable powerup.    + type: contains the power type.* BombComponent:     + ID: an unique id to identify this bomb explosion and avoid the destruction of child       asteroids.    + owner: the owner id to avoid the ship destruction, for now used by the player only.    + radius: the current explosion radius, used to scale the collider and the renderer.    + expansionSpeed: the scale speed used to scale collider and renderer.    + lifeTime: timer to check when to destroy the bomb entity.* ExplosionComponent: Visual effect representing the  explosion of an asteroid or a ship    + radius: the current explosion radius, used to scale the renderer    + expansionSpeed: the scale speed used to scale the renderer    + lifeTime: timer to check when destroy the entity* GameStateComponent: represents the state of the game. It's used to control the access to the   player entity when it was destroyed.  For the moment I defined two states, Running or Finished, but in the future this could be   useful to add new game states like pause, win, menu, etc.    + state: it could be Running or Finished.-------------------------------------------------------------------------------------------------ArchetypesBefore I start describing the archetypes I used, I need to describe the common Unity archetypes used and define some of them.First of all, I will describe the Unity archetype used to position the entity on the world, let's call it TransformEntity.All the entities add the LinkedEntityGroup component that makes the entity be the root of a set of connected entities, used to represent the whole hierarchy.* TransformEntity    + Translation: world position    + Rotation: world rotation    + LocalToWorld: world matrix Then we have a component that could be added, this is the Scale or one of his variants called NonUniformScale.Another archetype to describe is the used to represent the hierarchy, let's call it ChildTransformEntity and it could extend to TransformEntity.* ChildTransformEntity: TransformEntity    + Parent: reference to parent    + LocalToParent: parent matrixNow we have the Child component used to determine the child hierarchy on the parent Entity. lets call it ParentTransformEntity and it can extend the TransformEntity too.* ParentTransformEntity: TransformEntity    + Child    + LinkedEntityGroupThe next step is describing the Renderer archetypes, let's call it MeshRendererEntity.* MeshRendererEntity    + RenderMesh    + RenderBounds    + WorldRenderBounds    + ChunkWorldRenderBoundsNow will describe the Physics archetype, let's call it PhysicsEntity.* PhysicsEntity    + PhysicsMass    + PhysicsVelocity    + PhysicsGravity    + PhysicsDampingNow will describe the Collider calling it ColliderEntity.* ColliderEntity:    + PhysicsColliderBlobOnce this is done, I can start to describe the used archetypes for the DemoI will use multiple inheritance to describe the entity when it uses the archetypes mentioned above.* AsteroidEntity: TransformEntity, MeshRendererEntity, PhysicsEntity, ColliderEntity    + LimitCheckComponent    + HealthComponent    + AsteroidComponent* ShipEntity: ParentTransformEntity, PhysicsEntity, ColliderEntity    + LimitCheckComponent    + HealthComponent    + ShipDataComponent    + ShipInputComponent    + ShipStatsComponent    + WeaponComponent    + ShipRendererComponentThe ship Entity always contains two child Entities that are the mesh renderer and the Shield renderer (or aim renderer).* ShipMeshRendererEntity: ChildTransformEntity, MeshRendererEntity* ShieldMeshRendererEntity: ChildTransformEntity, MeshRendererEntityThe EnemyEntity and the PlayerEntity archetype extends the ShipEntity archetype.* EnemyEntity: ShipEntity    + EnemyComponent    + AimComponent In this case of enemy it adds, to the ShieldMeshRendererEntity archetype, a NonUniformScale component.* AimMeshRendererEntity: ShieldMeshRendererEntity    + NonUniformScale* PlayerEntity: ShipEntity    + PlayerComponent    + HyperspaceTravelComponentThe ShieldMeshRendererEntity of the PlayerEntity adds a ShieldComponent.* PlayerShieldMeshRendererEntity: ShieldMeshRendererEntity    + ShieldComponent* MissileEntity: TransformEntity, MeshRendererEntity    + MissileComponent* PowerEntity: ParentTransformEntity, MeshRendererEntity, ColliderEntity    + PowerComponent The PowerEntity contains a child renderer used to render the circle around the power icon.* PowerCircleRendererEntity: ChildTransformEntity, MeshRendererEntityThe BombEntity adds a Scale component to change the explosion radius.* BombEntity: TransformEntity, MeshRendererEntity, ColliderEntity    + BombComponent    + Scale The explosion adds a scale too, working similar to BombEntity.* ExplosionEntity: TransformEntity, MeshRendererEntity    + ExplosionComponent    + ScaleFinally we have the GameStateEntity.* GameStateEntity    + GameStateComponent-------------------------------------------------------------------------------------------------Systems    Spawn SystemsThe spawn systems are responsible to instantiate all the In game entities.All these systems follow the same idea. First, prepare the prefabs before conversion, because there are some entities that could have variants like the enemies or the asteroids.For this step the idea is the next.The first step is to read the appropriate data from data files saved into scriptable objects this includes the entity prefab object that is used to transform into an entity then using this data will modify the prefab, we can modify the prefab components without destroying or adding new components, in the most of cases it only creates a mesh using the point shape saved on the data, this process was described on the Graphics section.After doing that, will transform the prefab into an entity, this entity is known as entity prefab. I will save these entities into an array in the case of having several variants of the same object. This array will be sorted by object type, for example, asteroids have different types and shapes, they will be saved sorted by type and shape, and will be accessed using another array that will save the amount of shapes that each type has and the first index on the entity prefabs array. Then on the moment of access this data using the type we can know the correspondent indices on the entity prefabs array. Something like this will work with Enemies and Powers too but in this case each type has only one shape and there is no need to use an indices array. The other entities that need to be spawned are: player, explosions, missiles and the bomb. The last step to definitively instantiate the entities on the game scene is the next. The entity will be created using the selected prefab entity and some components will be added or modified depending on the saved data coming from scriptable objects. The moment to instantiate each entity will depend on the conditions of the game, it could be instantiated at the beginning, after checking some conditions or after some event invocation.	* ShipSpawn_System:This system is an abstract system that is used by inheritance for EnemiesSpawn_System and PlayerSpawn_System.It contains functions to create a ship prefab entity, create the line shape mesh using the saved data and instantiate a ship entity, used by the other two classes as a base to create their own entities (enemies or player).	* PlayerSpawn_System: ShipSpawn_SystemThe only purpose of this system is to spawn the player entity and add the needed data components using the saved data.* EnemiesSpawn_System: ShipSpawn_SystemThis system will save an array of enemy entity prefabs and will be responsible to spawn the enemies in the game depending on spawn parameters.It checks the amount of enemies and a timer to spawn random enemies when it's needed.	* AsteroidSpawn_SystemThis system will save an array of asteroid entity prefabs sorted by type and shape.This is responsible for spawning asteroids during the game and destroying them when their health is 0 or lower, spawning three child asteroids of the next smaller size if it is needed.The other task for this system is to check the total amount of asteroids on screen, adding the sizes and checking if another big random asteroid should be spawned.	* PowerSpawn_SystemSaves the power entity prefabs and spawn a random power when an AsteroidDesroyed or an EnemyDestroyed event is invoked. In the case of asteroids it needs to be medium or bigger.	* PlayerMissileSpawn_SystemSaves the missile entity prefab for player shoot and the angles of these missiles should be shooted.Checks if the shoot key is pressed taking into account the stunned timer and the cooldown and spawn the amount of missiles in the corresponding direction according to the player weapon component data.	* EnemyMissileSpawn_SystemThis system is similar to the PlayerMisileSpawn_System but with some differencesFirst, all enemies can spawn only one missile per shoot.The other difference is that the direction of that shot is looking to the player and is independent of the enemy look direction.	* ExplosionSpawn_SystemSaves an explosion prefab entity and instantiates an explosion in the position that an entity was destroyed, it could be asteroids, enemies or the player.Checks the events EntityDestroyed and AsteroidDestroyed.	* BombSpawn_SystemSaves a bomb prefab entity and instantiates a bomb entity when the player gets the bomb power. Checks the PowerPick event.	     Movement Systems	* ShipMovement_SystemThis system is responsible for reading the input and applying it to the Physics Velocity component present on the player and enemies. It takes into account the current velocity, the acceleration and the rotation of the ship.It clamps the speed to the maximum speed saved on the ShipDataComponent.	  * MisileMovement_SystemThis system only computes the next missile position and assigns it to the Translation component. Missiles only move forward.     Collision Systems	* AsteroidCollision_SystemApplies the physics described in the Physics section to the asteroids.	* ShipCollision_SystemApplies the physics described in the Physics section to the ships. and compute the collision between ships and asteroids.	  * MisileCollision_SystemRaycast to the forward using the range value as length of the ray.When it detects a hit entity with the HealthComponent, apply the damage to the health.In the case of an asteroid it needs to apply the explosion direction to the AsteroidComponent.In the case of a ship, it applies invulnerability time to the ShipStatsComponent and takes into account the shield health before normal health.Before applying damage it checks that the hit entity is not the owner of the missile.After doing the damage the missile will be destroyed.	* BombCollision_SystemChecks collisions inside a circle collider and expands its radius over time.In case of asteroids apply the explode direction and the last bomb ID to the AsteroidComponent.In all cases, except by the player, the health of the entities reached by the bomb will be put on 0 to destroy them.After the expansion time, the bomb entity will be destroyed.	  * PowerCheck_SystemChecks if the player collides with any Power and applies it to him when it happens.In the case of a bomb the BombSpawn_System will catch the PickPower event.After that the Power will be destroyed.	      Checks Systems* ShipStats_SystemChecks the ShipStatsComponent values.If the entity has a PlayerComponent then checks the ShieldComponent tooThe responsibility of this system is to apply the changes to the ship entities depending on their stats.Enable and Disable shield.Check health and destroy the ship entity if it is 0 or lower.Set the twinkle behavior to the ship renderer when it has invulnerability.This system calls some events after query, these events are used by the UI to update in-game stats.	  * Audio_SystemThis system checks the game events and calls to the AudioManager to play the correspondent sound.    Player Systems* PlayerInput_SystemApply the input to the ShipInputComponent and HyperspaceTravelComponent for the player entity.	* Shield_SystemAdd or remove the Disabled component to the Shield Renderer depending on the ShieldComponent data.	* HyperspaceTravel_SystemControls the hyperspace travel mentioned in the section Design and Mechanics.    Enemies Systems* EnemyAI_SystemControls the enemies AI mentioned in the section Design and Mechanics.    * AimPlayer_SystemControles the enemy aim system mentioned in the section Design and Mechanics.		    Other systems* GameState_SystemChecks the PlayerDestroyed event and changes the GameState to Finished if the player was destroyed.	  * LimitsCheck_SystemApply the Camera World Limits to all entities with the LimitCheckComponent.Teleport the entities that are out of the screen to the other side of the screen.This sometimes causes problems with the collision system and could causes some sound glitches.	* Explosion_SystemExpands the Scale of the entities with ExplosionComponent, and destroys it after expansion timer is done.======================================================================        Event System======================================================================In the middle of the development emerges the necessity to invoke events.The main problem was how to connect with a supposed sound system without calling it directly from the code. Then I had the idea of making a publish-subscribe event system with a circular stream that the publishers can write and the subscriber can read. For simplicity let's call this structure an event publisher.	The publisher is the process that invokes the event, for example, an AsteroidDestroyed event should be invoked when an asteroid is destroyed, in this case the publisher posts the event on the event publisher that contains the streams that are waiting for that event.	The subscriber needs to check his stream from time to time to get the new events. Each subscriber has his own stream that will be written by the publisher when an event has come.To read the stream is necessary a Consumer, this structure contains the index of the subscriber stream and is assigned when the subscriber is subscribed to the event publisher.	To make this process more efficient and avoid the double array structure inside the event publisher I used a single events array divided in streams of the same length. The length of the streams is setted on the constructor with the max number of subscribers that the event publisher can manage.	The events not readed when a publisher post an event will be overwritten if the stream is fullThe consumer and the event publisher have a hash value used to identify if the consumer used to read the stream was created by that event publisher. If a subscriber tries to read from a stream using the wrong consumer it will throw an error.	After that, I created a System with static event publishers for each event type I need to invoke.This system called Events_System is responsible for instantiating the event publishers on create and Dispose them on destroy.The next diagram is an example of the event publisher receiving an event post by a publisher and the reads by the subscribers. In this diagram the length of the circular stream of each subscriber is 10, the numbers above each stream are the indices of the array structure. The numbers between parentheses are the consumer index needed to access the corresponding stream.                                ┌─────────┐                                 │ Post(X) │              ┌────────────┐    └────┬────┘              │ Publisher  ├»────────┴─────────────┐              └────────────┘                       │                                        0   1   2  │3   4   5   6   7   8   9          ┌───────────────┐           ╔───╦───╦───╦┼──╦───╦───╦───╦───╦───╦───╗          │ Subscriber(0) ├«────┬─────╫───╫───╫[X◄╫┤  ║   ║   ║   ║   ║   ║   ║          └───────────────┘ ┌───┴───┐ ╚───╩───╩───╩┼──╩───╩───╩───╩───╩───╩───╝                            │Read(0)│              │                            └───────┘   10  11  12 │13  14  15  16  17  18  19          ┌───────────────┐           ╔───╦───╦───╦┼──╦───╦───╦───╦───╦───╦───╗          │ Subscriber(1) ├«────┬─────╫───╫───╫[X◄╫┤  ║   ║   ║   ║   ║   ║   ║          └───────────────┘ ┌───┴───┐ ╚───╩───╩───╩┼──╩───╩───╩───╩───╩───╩───╝                            │Read(1)│              │                            └───────┘   20  21  22 │23  24  25  26  27  28  29           ┌───────────────┐           ╔───╦───╦───╦┼──╦───╦───╦───╦───╦───╦───╗          │ Subscriber(2) ├«────┬─────╫───╫───╫[X◄╫┤  ║   ║   ║   ║   ║   ║   ║          └───────────────┘ ┌───┴───┐ ╚───╩───╩───╩┼──╩───╩───╩───╩───╩───╩───╝                            │Read(2)│              │                            └───────┘   30  31  32 │33  34  35  36  37  38  39           ┌───────────────┐           ╔───╦───╦───╦┼──╦───╦───╦───╦───╦───╦───╗          │ Subscriber(4) ├«────┬─────╫───╫───╫[X◄╫┤  ║   ║   ║   ║   ║   ║   ║          └───────────────┘ ┌───┴───┐ ╚───╩───╩───╩┼──╩───╩───╩───╩───╩───╩───╝                 :          │Read(4)│              │                 ∙          └───────┘              :                                                   ∙The (0) on the subscriber indicates the consumer ID		======================================================================        Sound System======================================================================The first step before starting to implement this system was research about sound system technologies compatible with Unity DOTS. The first result was a library called Unity.Tiny.Audio.The problem with Unity.Tiny.Audio was it is a part of the Unity.Tiny package and it isn't directly compatible with DOTS, this is a completely separate system and it's impossible, or at least too complicated, to separate the Audio library from the rest of the package. After trying for several hours without a positive result I decided to continue researching.	The second try was with a library called DSPGraph, this library works but literally blocks the Unity editor. The block occurs when trying to compile code after the first time the editor enters in play mode. Debugging I found that the problem could be some kind of non disposed memory on the native library but after trying for another couple of hours I cannot find a solution for this issue. Then I decided to discard the changes and go for the Unity Audio System.	For this I implemented a Sound Manager that contains an audio database with sounds and a pool of AudioSources.The idea of this Sound Manager is to play sound effects in parallel using the Pool. The pool contains an amount of instantiated AudioSources.The sound effects are mapped using a SoundType enum to differentiate each other. Let's call this the audio database.	To connect the SoundManager with the rest of the systems I have the Audio_System that contains a reference to the Sound Manager and is responsible to check the Events coming from the Events_System and call the Sound Manager with the corresponding Sound Type.======================================================================        System Initialization and Configuration======================================================================On this part we need to find a way to give the initial data to the systems, Prefab references, initial attributes, parameters, etc.I decided to implement a static class that provides all this data in an easy way. This class, called Configs, will save all the saved data or databases coming from scriptable objects, the needed constants and configuration variables that I need.This is not the best approach for a big extensive project but it's the more quick to implement for this project, that needs all the data at the begining to create the entities prefabs. This and taking into account that the size of the data is not too expensive, cause I am not using sprites or stored meshes and textures, I decided to use this approach.The right approach maybe could be to load the assets with Addressables or implement some kind of load under demand. Again, the demand in this case is at the beginning and I prioritize the simplicity before the efficiency because probably I could not win too much efficiency.	Having said that I proceed to describe the data structures saved into Scriptable objects    * AsteroidDataSOSaves the Asteroid prefab reference and an array of AsteroidData. Each AsteroidData can contain one or more shapes constituted by 2D points.The idea is to have one AsteroidData for each asteroid type.		* WeaponDataSOSaves the missile prefab reference and another prefab, that in case of PlayerWeaponsData saves the Bomb prefab reference and in the case of EnemiesWeaponsData saves the Explosion prefab reference.Then saves an array of WeaponData that stores the weapon attributes: missileAmount, missileSpeed, missileLifeTime, range. In the case of the player this array represents the weapon levels, and in the case of enemies each WeaponData belongs to each enemy type.Another attribute is the MisileAngleDeg array that stores the angles that the missiles should aim when they are instantiated.And finally we have the MissileShape that is the array of 2D points representing the missile shape.		* ShipDataSOSaves a reference to the ShipPrefab, a ShipData array and a reference to WeaponDataSO.The ShipData stores the attributes of the ship, including the shape.For the player the ShipData array contains only one ShipData at this moment but it could be extended easily adding more ShipData with different attributes, this could work to have several options at the time to select a ship to play.For enemies this array contains the different enemies that could appear in the game.* PowerDataSOContains the Power prefab reference, a Material for circle and a material for the icon, the circle radius and an array of PowerData with the different power types.Each power data has a type, a color and a shape for the icon.		* AudioDataSOContains the SoundClip references inside a mapped array using the AudioType enum as key. and the AudioSource prefab prepared for creating the Pool inside SoundManager.		* GameDataSOContains SpawnData for asteroids and Enemies, and the Hyperspace Travel data		To initialize the Configs class I used a MonoBehaviour object that contains all needed references and passed them to Configs class. This initialization class is named InitializeConfigs and contains the following references.+ Camera: The main camera of the scene used to calculate Camera Limits.+ GameData: the GameDataSO.+ AsteroidDB: the AsteroidDataSO, ot Asteroids Database.+ PowerDB: the PowerDataSO, or Powers Database.+ AudioDB: the AudioDataSO, or Audio Database.+ PlayerData: the ShipDataSO containing player data.+ EnemyData: the ShipDataSO containing enemy data, or Enemy Database.+ SoundManager: The reference to the SoundManager on the scene.======================================================================        Observations======================================================================The Events_System solution with static variables maybe is not the best solution taking into account that I am using ECS. The necessity of writing into another portion of memory when invoked an event isn’t compatible with the idea of the ECS system and I thought that maybe using an ECS structure for the events, they could be invoked a little bit late, enough so the player can notice the delay.The idea of using the burst compiler was discarded due to the difficulty and the restrictions it has. Maybe some systems can use it without problems but most of them need to read from other ECS structures, like for example the collision systems.======================================================================        Appendix======================================================================    Symbols            ╔═════════════╗            ║Symbols Used ║            ║═════════════║            ║ ► ◄ » «     ║            ║ ╗ ╝ ╚ ╔ ║ ═ ║            ║ ┐ ┘ └ ┌ │ ─ ║            ║ ╟ ╢ ╧ ╤ ╩ ╦ ║            ║ ├ ┤ ┴ ┬     ║            ║ ┼ ╫ ╪       ║            ╚═════════════╝			